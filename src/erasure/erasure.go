package erasure

/*
#cgo CFLAGS: -Wall
#include "types.h"
#include "erasure_code.h"
*/
import "C"

import (
	"fmt"
	"unsafe"
)

func Hello() {
	m := 12
	k := 8
	sourceLength := 16

	source := make([]byte, k*sourceLength)
	destination := make([]byte, m*sourceLength)

	for i := range source {
		source[i] = 0x62
	}

	encodeMatrix := make([]byte, m*k)
	// decode_matrix := make([]byte, m*k)
	// invert_matrix := make([]byte, m*k)
	g_tbls := make([]byte, k*(m-k)*32)

	// fmt.Printf("Encode Matrix: %x\n", encode_matrix)

	// Generate encode matrix encode_matrix
	// The matrix generated by gf_gen_cauchy1_matrix
	// is always invertable.
	C.gf_gen_cauchy1_matrix((*C.uchar)(&encodeMatrix[0]), C.int(m), C.int(k))
	// The matrix generated by gf_gen_rs_matrix
	// is not always invertable.
	// C.gf_gen_rs_matrix((*C.uchar)(&encode_matrix[0]), C.int(m), C.int(k))

	fmt.Printf("Encode Matrix: %x\n", encodeMatrix)

	// fmt.Printf("G Tables: %x\n", g_tbls)
	C.ec_init_tables(C.int(k), C.int(m-k), (*C.uchar)(&encodeMatrix[k*k]), (*C.uchar)(&g_tbls[0]))
	fmt.Printf("G Tables: %x\n", g_tbls)

	fmt.Printf("Source: %x\n", source)
	C.ec_encode_data(C.int(sourceLength), C.int(k), C.int(m), (*C.uchar)(&g_tbls[0]), (*C.uchar)(&source[0]), (*C.uchar)(&destination[0]))
	fmt.Printf("Dest: %x\n", destination)

	decodeMatrix := make([]byte, m*k)
	decodeIndex := make([]int32, m)
	srcErrList := make([]int32, m)
	srcInErr := make([]int32, m-k)

	srcErrList[8] = 1
	srcErrList[9] = 1
	srcErrList[10] = 1
	srcErrList[11] = 1
	srcInErr[0] = 8
	srcInErr[1] = 9
	srcInErr[2] = 10
	srcInErr[3] = 11

	nErrs := 4
	nSrcErrs := 4

	C.gf_gen_decode_matrix((*C.uchar)(&encodeMatrix[0]), (*C.uchar)(&decodeMatrix[0]), (*C.uint)(unsafe.Pointer(&decodeIndex[0])), (*C.uchar)(unsafe.Pointer(&srcErrList[0])), (*C.uchar)(unsafe.Pointer(&srcInErr[0])), C.int(nErrs), C.int(nSrcErrs), C.int(k), C.int(m))
	fmt.Printf("Decode Matrix: %x\n", decodeMatrix)
	fmt.Printf("Decode Index: %x\n", decodeIndex)

	g_tbls = make([]byte, k*(m-k)*32)

	C.ec_init_tables(C.int(k), C.int(nErrs), (*C.uchar)(&decodeMatrix[0]), (*C.uchar)(&g_tbls[0]))
	fmt.Printf("G Tables: %x\n", g_tbls)

	recovered := make([]byte, m*sourceLength)
	C.ec_encode_data(C.int(sourceLength), C.int(k), C.int(m), (*C.uchar)(&g_tbls[0]), (*C.uchar)(&destination[0]), (*C.uchar)(&recovered[0]))
	fmt.Printf("Recovered: %x\n", recovered)
}
