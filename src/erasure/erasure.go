package erasure

/*
#cgo CFLAGS: -Wall
#include "types.h"
#include "erasure_code.h"
*/
import "C"

import (
	"fmt"
	"unsafe"
)

func Hello() {
	m := 12
	k := 8
	sourceLength := 16

	source := make([]byte, k*sourceLength)
	destination := make([]byte, m*sourceLength)

	for i := range source {
		source[i] = 0x60
	}

	encodeMatrix := make([]byte, m*k)
	// decode_matrix := make([]byte, m*k)
	// invert_matrix := make([]byte, m*k)
	g_tbls := make([]byte, k*(m-k)*32)

	// fmt.Printf("Encode Matrix: %x\n", encode_matrix)

	// Generate encode matrix encode_matrix
	// The matrix generated by gf_gen_cauchy1_matrix
	// is always invertable.
	C.gf_gen_cauchy1_matrix((*C.uchar)(&encodeMatrix[0]), C.int(m), C.int(k))
	// The matrix generated by gf_gen_rs_matrix
	// is not always invertable.
	// C.gf_gen_rs_matrix((*C.uchar)(&encode_matrix[0]), C.int(m), C.int(k))

	// fmt.Printf("Encode Matrix: %x\n", encode_matrix)

	// fmt.Printf("G Tables: %x\n", g_tbls)
	C.ec_init_tables(C.int(k), C.int(m-k), (*C.uchar)(&encodeMatrix[0]), (*C.uchar)(&g_tbls[0]))
	fmt.Printf("G Tables: %x\n", g_tbls)

	fmt.Printf("Sources: %x\n", source)
	C.ec_encode_data(C.int(sourceLength), C.int(k), C.int(m), (*C.uchar)(&g_tbls[0]), (*C.uchar)(&source[0]), (*C.uchar)(&destination[0]))
	fmt.Printf("Dest: %x\n", destination)

	decodeMatrix := make([]byte, m*k)
	decodeIndex := make([]int, m)
	srcErrList := make([]int, m)
	srcInErr := make([]int, m-k)

	srcErrList[0] = 1
	srcErrList[1] = 1
	srcErrList[2] = 1
	srcErrList[3] = 1
	srcInErr[0] = 0
	srcInErr[1] = 1
	srcInErr[2] = 2
	srcInErr[3] = 3

	nErrs := 4
	nSrcErrs := 4

	C.gf_gen_decode_matrix((*C.uchar)(&encodeMatrix[0]), (*C.uchar)(&decodeMatrix[0]), (*C.uint)(unsafe.Pointer(&decodeIndex[0])), (*C.uchar)(unsafe.Pointer(&srcErrList[0])), (*C.uchar)(unsafe.Pointer(&srcInErr[0])), C.int(nErrs), C.int(nSrcErrs), C.int(k), C.int(m))
}
